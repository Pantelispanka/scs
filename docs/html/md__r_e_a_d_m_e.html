<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SuperSCS: SCS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SuperSCS
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SCS </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/kul-forbes/scs">![Build Status](https://travis-ci.org/kul-forbes/scs.svg?branch=master)</a></p>
<p>SCS (<code>splitting conic solver</code>) is a numerical optimization package for solving large-scale convex cone problems, based on our paper <a href="http://www.stanford.edu/~boyd/papers/scs.html">Conic Optimization via Operator Splitting and Homogeneous Self-Dual Embedding</a>. It is written in C and can be used in other C, C++, Python, Matlab, R, Julia, Java, and Scala programs via included interfaces (Julia interface available <a href="https://github.com/JuliaOpt/SCS.jl">here</a>). It can also be called as a solver from convex optimization toolboxes <a href="http://cvxr.com/cvx/">CVX</a> (3.0 or later), <a href="https://github.com/cvxgrp/cvxpy">CVXPY</a>, <a href="https://github.com/JuliaOpt/Convex.jl">Convex.jl</a>, and <a href="https://github.com/johanlofberg/YALMIP">Yalmip</a>.</p>
<p>The current version is <code>1.2.6</code>. If you wish to cite SCS, please use the following: ``` {ocpb:16, author = {B. O'Donoghue and E. Chu and N. Parikh and S. Boyd}, title = {Conic Optimization via Operator Splitting and Homogeneous Self-Dual Embedding}, journal = {Journal of Optimization Theory and Applications}, month = {June}, year = {2016}, volume = {169}, number = {3}, pages = {1042-1068}, url = {<a href="http://stanford.edu/~boyd/papers/scs.html">http://stanford.edu/~boyd/papers/scs.html</a>}, } {scs, author = {B. O'Donoghue and E. Chu and N. Parikh and S. Boyd}, title = {{SCS}: Splitting Conic Solver, version 1.2.6}, howpublished = {{<a href="https://github.com/cvxgrp/scs">https://github.com/cvxgrp/scs</a>}}, month = apr, year = 2016 } ``` </p>
<hr/>
<p> SCS numerically solves convex cone programs using the alternating direction method of multipliers (<a href="http://web.stanford.edu/~boyd/papers/admm_distr_stats.html">ADMM</a>). It returns solutions to both the primal and dual problems if the problem is feasible, or a certificate of infeasibility otherwise. It solves the following primal cone problem:</p>
<p>``` minimize c'x subject to Ax + s = b s in K ``<code> over variables</code>x<code>and</code>s<code>, where</code>A<code>,</code>b<code>and</code>c<code>are user-supplied data and</code>K` is a user-defined convex cone. The dual problem is given by ``` maximize -b'y subject to -A'y == c y in K^* ``<code> over variable</code>y<code>, where</code>K^*<code>denotes the dual cone to</code>K`.</p>
<p>The cone <code>K</code> can be any Cartesian product of the following primitive cones:</p>
<ul>
<li>zero cone <code>{x | x = 0 }</code> (dual to the free cone <code>{x | x in R}</code>)</li>
<li>positive orthant <code>{x | x &gt;= 0}</code></li>
<li>second-order cone <code>{(t,x) | ||x||_2 &lt;= t}</code></li>
<li>positive semidefinite cone <code>{ X | min(eig(X)) &gt;= 0, X = X^T }</code></li>
<li>exponential cone <code>{(x,y,z) | y e^(x/y) &lt;= z, y&gt;0 }</code></li>
<li>dual exponential cone <code>{(u,v,w) | âˆ’u e^(v/u) &lt;= e w, u&lt;0}</code></li>
<li>power cone <code>{(x,y,z) | x^a * y^(1-a) &gt;= |z|, x&gt;=0, y&gt;=0}</code></li>
<li>dual power cone <code>{(u,v,w) | (u/a)^a * (v/(1-a))^(1-a) &gt;= |w|, u&gt;=0, v&gt;=0}</code></li>
</ul>
<p>The rows of the data matrix <code>A</code> correspond to the cones in <code>K</code>. <b>The rows of <code>A</code> must be in the order of the cones given above, i.e., first come the rows that correspond to the zero/free cones, then those that correspond to the positive orthants, then SOCs, etc.</b> For a <code>k</code> dimensional semidefinite cone when interpreting the rows of the data matrix <code>A</code> SCS assumes that the <code>k x k</code> matrix variable has been vectorized by scaling the off-diagonal entries by <code>sqrt(2)</code> and stacking the <b>lower triangular elements column-wise</b> to create a vector of length <code>k(k+1)/2</code>. See the section on semidefinite programming below.</p>
<p>At termination SCS returns solution <code>(x*, s*, y*)</code> if the problem is feasible, or a certificate of infeasibility otherwise. See <a href="http://web.stanford.edu/~boyd/cvxbook/">here</a> for (much) more details about cone programming and certificates of infeasibility.</p>
<p><b>Semidefinite Programming</b></p>
<p>SCS assumes that the matrix variables and the input data corresponding to semidefinite cones have been vectorized by <b>scaling the off-diagonal entries by <code>sqrt(2)</code></b> and stacking the lower triangular elements <b>column-wise</b>. For a <code>k x k</code> matrix variable (or data matrix) this operation would create a vector of length <code>k(k+1)/2</code>. Scaling by <code>sqrt(2)</code> is required to preserve the inner-product.</p>
<p><b>To recover the matrix solution this operation must be inverted on the components of the vector returned by SCS corresponding to semidefinite cones</b>. That is, the off-diagonal entries must be scaled by <code>1/sqrt(2)</code> and the upper triangular entries are filled in by copying the values of lower triangular entries.</p>
<p>More explcitly, we want to express <code>Tr(C X)</code> as `vec(C)'*vec(X)<code>, where the</code>vec<code>operation takes the</code>k x k<code>matrix </code>`` X = [ X11 X12 ... X1k X21 X22 ... X2k ... Xk1 Xk2 ... Xkk ] ``` and produces a vector consisting of ``` vec(X) = (X11, sqrt(2)*X21, ..., sqrt(2)*Xk1, X22, sqrt(2)*X32, ..., Xkk). ```</p>
<p><b>Linear equation solvers</b></p>
<p>Each iteration of SCS requires the solution of a set of linear equations. This package includes two implementations for solving linear equations: a direct solver which uses a cached LDL factorization and an indirect solver based on conjugate gradients. The indirect solver can be run on either the cpu or gpu.</p>
<p>The direct solver uses the LDL and AMD packages numerical linear algebra packages by Timothy Davis and others, the necessary files are included. See <a href="http://www.cise.ufl.edu/research/sparse/">here</a> for more information about these packages.</p>
<h3>Using SCS in C</h3>
<p>Typing <code>make</code> at the command line will compile the code and create SCS libraries in the <code>out</code> folder. It will also produce six demo binaries in the <code>out</code> folder named <code>demo_direct</code>, <code>demo_indirect</code>, <code>demo_gpu</code>, <code>demo_SOCP_direct</code>, <code>demo_SOCP_indirect</code>, and <code>demo_SOCP_gpu</code>.</p>
<p>If <code>make</code> completes successfully, it will produce three static library files, <code>libscsdir.a</code>, <code>libscsindir.a</code>, and <code>libscsgpu.a</code> under the <code>out</code> folder and three dynamic library files <code>libscsdir.ext</code>, <code>libscsindir.ext</code>, and <code>libscsgpu.ext</code> (where <code>.ext</code> extension is platform dependent) in the same folder. To include the libraries in your own source code, compile with the linker option with <code>-L(PATH_TO_SCS)\out</code> and <code>-lscsdir</code> or <code>-lscsindir</code> (as needed).</p>
<p>These libraries (and <code><a class="el" href="scs_8h.html">scs.h</a></code>) expose only four API functions:</p>
<ul>
<li><p class="startli"><code>Work * <a class="el" href="scs_8h.html#ac80aff1c3011a5cc31ba32c8e3689f01">scs_init(const Data * d, const Cone * k, Info * info)</a>;</code></p>
<p class="startli">This initializes the Work struct containing the workspace that scs will use, and performs the necessary preprocessing (e.g. matrix factorization). All inputs <code>d</code>, <code>k</code>, and <code>info</code> must be memory allocated before calling.</p>
</li>
<li><p class="startli"><code>scs_int <a class="el" href="scs_8h.html#ae5a022dbf33560ad0564178ff61d535d">scs_solve(Work * w, const Data * d, const Cone * k, Sol * sol, Info * info)</a>;</code></p>
<p class="startli">This solves the problem as defined by Data <code>d</code> and Cone <code>k</code> using the workspace in <code>w</code>. The solution is returned in <code>sol</code> and information about the solve is returned in <code>info</code> (outputs must have memory allocated before calling). None of the inputs can be NULL. You can call <code>scs_solve</code> many times for one call to <code>scs_init</code>, so long as the matrix <code>A</code> does not change (vectors <code>b</code> and <code>c</code> can change).</p>
</li>
<li><p class="startli"><code>void <a class="el" href="scs_8h.html#a444d62ce119a1e4762f87fe263369047">scs_finish(Work * w)</a>;</code></p>
<p class="startli">Called after all solves completed to free allocated memory and other cleanup.</p>
</li>
<li><p class="startli"><code>scs_int <a class="el" href="scs_8h.html#a103f47be236f81ae085244d574997706">scs(const Data * d, const Cone * k, Sol * sol, Info * info)</a>;</code></p>
<p class="startli">Convenience method that simply calls all the above routines in order, for cases where the workspace does not need to be reused. All inputs must have memory allocated before this call.</p>
</li>
</ul>
<p>The relevant data structures are: ```C </p>
<pre class="fragment">typedef struct SCS_PROBLEM_DATA Data;
typedef struct SCS_SETTINGS Settings;
typedef struct SCS_SOL_VARS Sol;
typedef struct SCS_INFO Info;
typedef struct SCS_SCALING Scaling;
typedef struct SCS_WORK Work;
typedef struct SCS_CONE Cone;

/* defined in linSys.h, can be overriden by user 
typedef struct A_DATA_MATRIX AMatrix;

/* this struct defines the data matrix A 
struct A_DATA_MATRIX {
    /* A is supplied in column compressed format 
    scs_float * x;      /* A values, size: NNZ A 
    scs_int * i;        /* A row index, size: NNZ A 
    scs_int * p;        /* A column pointer, size: n+1 
    scs_int m, n;       /* m rows, n cols 
};

/* struct containing problem data 
struct SCS_PROBLEM_DATA {
    /* these cannot change for multiple runs for the same call to scs_init 
    scs_int m, n;       /* A has m rows, n cols 
    AMatrix * A;        /* A is supplied in data format specified by linsys solver 

    /* these can change for multiple runs for the same call to scs_init 
    scs_float * b, *c;  /* dense arrays for b (size m), c (size n) 

    Settings * stgs;    /* contains solver settings specified by user 
};

/* struct containing solver settings 
struct SCS_SETTINGS {
    /* settings parameters: default suggested input 

    /* these *cannot* change for multiple runs with the same call to scs_init 
    scs_int normalize;  /* boolean, heuristic data rescaling: 1 
    scs_float scale;    /* if normalized, rescales by this factor: 5 
    scs_float rho_x;    /* x equality constraint scaling: 1e-3 

    /* these can change for multiple runs with the same call to scs_init 
    scs_int max_iters;  /* maximum iterations to take: 2500 
    scs_float eps;      /* convergence tolerance: 1e-3 
    scs_float alpha;    /* relaxation parameter: 1.8 
    scs_float cg_rate;  /* for indirect, tolerance goes down like (1/iter)^cg_rate: 2 
    scs_int verbose;    /* boolean, write out progress: 1 
    scs_int warm_start; /* boolean, warm start (put initial guess in Sol struct): 0 
};   

/* contains primal-dual solution arrays 
struct SCS_SOL_VARS {
    scs_float * x, *y, *s;
};

/* contains terminating information 
struct SCS_INFO {
    scs_int iter;       /* number of iterations taken 
    char status[32];    /* status string, e.g. 'Solved' 
    scs_int statusVal;  /* status as scs_int, defined below 
    scs_float pobj;     /* primal objective 
    scs_float dobj;     /* dual objective 
    scs_float resPri;   /* primal equality residual 
    scs_float resDual;  /* dual equality residual 
    scs_float resInfeas;/* infeasibility cert residual 
    scs_float resUnbdd; /* unbounded cert residual 
    scs_float relGap;   /* relative duality gap 
    scs_float setupTime;/* time taken for setup phase (milliseconds) 
    scs_float solveTime;/* time taken for solve phase (milliseconds) 
};


/* contains normalization variables 
struct SCS_SCALING {
    scs_float *D, *E; /* for normalization 
    scs_float meanNormRowA, meanNormColA;
};

/* NB: rows of data matrix A must be specified in this exact order 
struct SCS_CONE {
    scs_int f;          /* number of linear equality constraints 
    scs_int l;          /* length of LP cone 
    scs_int *q;         /* array of second-order cone constraints 
    scs_int qsize;      /* length of SOC array 
    scs_int *s;         /* array of SD constraints 
    scs_int ssize;      /* length of SD array 
    scs_int ep;         /* number of primal exponential cone triples 
    scs_int ed;         /* number of dual exponential cone triples 
    scs_int psize;      /* number of (primal and dual) power cone triples 
    scs_float * p;      /* array of power cone params, must be \in [-1, 1],
                           negative values are interpreted as specifying the dual cone 
};

/* SCS returns one of the following integers: (zero never returned)     
#define SCS_INFEASIBLE_INACCURATE   (-7)
#define SCS_UNBOUNDED_INACCURATE    (-6)
#define SCS_SIGINT                  (-5)
#define SCS_FAILED                  (-4)
#define SCS_INDETERMINATE           (-3)
#define SCS_INFEASIBLE              (-2) /* primal infeasible, dual unbounded   
#define SCS_UNBOUNDED               (-1) /* primal unbounded, dual infeasible   
#define SCS_UNFINISHED              (0)  /* never returned, used as placeholder 
#define SCS_SOLVED                  (1)
#define SCS_SOLVED_INACCURATE       (2)
</pre><p> ```</p>
<p>The types <code>scs_float</code> and <code>scs_int</code> can be specified by the user, they default to <code>double</code> and <code>int</code> respectively.</p>
<p>The data matrix <code>A</code> is specified in column-compressed format and the vectors <code>b</code> and <code>c</code> are specified as dense arrays. The solutions <code>x</code> (primal), <code>s</code> (slack), and <code>y</code> (dual) are returned as dense arrays. Cones are specified as the struct above, the rows of <code>A</code> must correspond to the cones in the exact order as specified by the cone struct (i.e. put linear cones before second-order cones etc.).</p>
<p><b>Warm-start</b></p>
<p>You can warm-start SCS (supply a guess of the solution) by setting warm_start in Data to <code>1</code> and supplying the warm-starts in the Sol struct (<code>x</code>,<code>y</code>, and <code>s</code>). All inputs must be warm-started if any one is. These are used to initialize the iterates in <code>scs_solve</code>.</p>
<p><b>Re-using matrix factorization</b></p>
<p>If using the direct version you can factorize the matrix once and solve many times. Simply call scs_init once, and use <code>scs_solve</code> many times with the same workspace, changing the input data <code>b</code> and <code>c</code> (and optionally warm-starts) for each iteration. See run_scs.c for an example.</p>
<p><b>Using your own linear system solver</b></p>
<p>To use your own linear system solver simply implement all the methods and the two structs in <code><a class="el" href="lin_sys_8h.html">include/linSys.h</a></code> and plug it in.</p>
<p><b>Solving SDPs</b></p>
<p>In order to solve SDPs you must have BLAS and LAPACK installed. Edit <code>scs.mk</code> to set <code>USE_LAPACK = 1</code> and point to the location of these libraries. Without these you can still solve problems using the other cones.</p>
<h3>Using SCS in Matlab</h3>
<p>Running <code>make_scs</code> in Matlab under the <code>matlab</code> folder will produce two mex files, one for each of the direct and indirect solvers.</p>
<p>Remember to include the <code>matlab</code> directory in your Matlab path if you wish to use the mex file in your Matlab code. The calling sequence is (for the indirect version): </p>
<pre class="fragment">[x,y,s,info] = scs_indirect(data,cones,settings)
</pre><p>where data is a struct containing <code>A</code>, <code>b</code>, and <code>c</code>, settings is a struct containing solver options (see matlab file, can be empty), and cones is a struct that contains one or more of:</p>
<ul>
<li><code>f</code> (num primal zero / dual free cones, i.e. primal equality constraints)</li>
<li><code>l</code> (num linear cones)</li>
<li><code>q</code> (array of SOCs sizes)</li>
<li><code>s</code> (array of SDCs sizes)</li>
<li><code>ep</code> (num primal exponential cones)</li>
<li><code>ed</code> (num dual exponential cones)</li>
<li><code>p</code> (array of primal/dual power params).</li>
</ul>
<p>Type <code>help scs_indirect</code> at the Matlab prompt to see its documentation.</p>
<h3>Using SCS in Python</h3>
<p>To install SCS as a python package type: ```shell cd &lt;scs-directory&gt;/python python setup.py install ``<code> You may need</code>sudo` privileges for a global installation. Running SCS requires numpy and scipy to be installed. You can install the gpu interface using ```shell python setup.py install &ndash;scs &ndash;gpu ```</p>
<p>After installing the SCS interface, you import SCS using ```python import scs ``<code> This module provides a single function</code>scs<code>with the following call signature: </code>``python sol = scs(data, cone, [use_indirect=True, gpu=False, verbose=True, normalize=True, max_iters=2500, scale=5, eps=1e-3, cg_rate=2, alpha=1.8, rho_x=1e-3]) ``` Arguments in the square brackets are optional, and default to the values on the right of their respective equals signs. The argument <code>data</code> is a python dictionary with three elements <code>A</code>, <code>b</code>, and <code>c</code> where <code>b</code> and <code>c</code> are NUMPY arrays (i.e., matrices with a single column) and <code>A</code> is a SCIPY <b>sparse matrix in CSC format</b>; if they are not of the proper format, SCS will attempt to convert them.</p>
<p>The argument <code>cone</code> is a dictionary with fields <code>f</code>, <code>l</code>, <code>q</code>, <code>s</code>, <code>ep</code>, <code>ed</code>, and <code>p</code> (all of which are optional) corresponding to the supported cone types.</p>
<p>The returned object is a dictionary containing the fields `sol['x']<code>,</code>sol['y']<code>,</code>sol['s']<code>, and</code>sol['info']`. The first three are NUMPY arrays containing the relevant solution. The last field contains a dictionary with solver information.</p>
<h3>Using SCS in Java / Scala</h3>
<p>SCS can be called from Java and Scala via the Java Native Interface (JNI). Typing <code>make</code> in the <code>java</code> directory will compile the native libraries into <code>java/bin</code> and build <code>scs.jar</code>. You will need to add these files to your java projects to use SCS. To test a random cone program type <code>make testproblem</code>.</p>
<p>To use with eclipse follow the above steps, then import <code>scs.jar</code> into eclipse and link the dynamic libraries (<code>libscsjdir.*</code> <code>libscsjindir.*</code>):</p>
<p>``` Project &gt; Properties &gt; Build Path &gt; Open scs.jar &gt; Native Library &gt; Edit &gt; Select the folder with libraries ```</p>
<p>To solve a problem create a new instance of <code>ConeProgram</code> with constructor</p>
<p>```Java public ConeProgram(Data d, Cone k, Settings p, IConeSolver solver); ```</p>
<p>where the <code>IConeSolver</code> interface can be one of <code>DirectSolver</code> or <code>IndirectSolver</code>. Then call</p>
<p>```Java ConeProgram.solve(); ```</p>
<p>on your instance of <code>ConeProgram</code>, which will return an instance of <code>Solution</code>, containing the solution and information about the run.</p>
<h3>Using SCS in R</h3>
<p>To install SCS as an R packge cd into the <code>r</code> subdirectory and type ```shell ./install.sh ``<code> and to test type</code>R &ndash;no-save &lt; demo/randomLp.R` (this is also called by the install script).</p>
<p>To call SCS use the function <code>scs</code>, defined as ```R scs &lt;- function(A, b, c, cone, params) ``<code> where</code>A<code>is a</code>Matrix<code>object,</code>b<code>and</code>c<code>are vectors, and</code>cone<code>and</code>params` are lists specifying the cone dimensions and input params respectively.</p>
<h3>Using SCS in Julia</h3>
<p>See usage instructions <a href="https://github.com/JuliaOpt/SCS.jl">here</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 26 2017 11:54:02 for SuperSCS by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
